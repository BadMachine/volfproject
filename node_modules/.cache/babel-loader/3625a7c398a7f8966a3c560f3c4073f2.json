{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\Bumpy\\\\WebstormProjects\\\\volfproject\\\\src\\\\components\\\\drawCOCOimage.tsx\";\nimport React from 'react'; //import * as React from 'react';\n\nimport { randomColor } from '../interfaces/SortInterfaces';\nimport { OverlayTrigger, Tooltip } from 'react-bootstrap';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nexport class DrawCOCOimage extends React.Component {\n  constructor(props) {\n    super(props);\n    this.canvas = void 0;\n    this.canvasForeground = void 0;\n    this.imageHasBeenLoaded = void 0;\n    this.tooltipRef = void 0;\n    this.data = void 0;\n    this.hColors = void 0;\n    this.hColors = Array.from({\n      length: 150\n    }, () => `rgba(${randomColor()}, ${randomColor()}, ${randomColor()}, 0.4`);\n    this.tooltipRef = /*#__PURE__*/React.createRef();\n    this.imageHasBeenLoaded = false;\n    this.data = {\n      bboxes: [],\n      segments: [],\n      descriptions: []\n    };\n  }\n\n  componentDidMount() {\n    this.updateImage();\n  }\n\n  handleMouse(e) {\n    const ctx = this.canvasForeground.getContext('2d');\n    const rect = this.canvasForeground.getBoundingClientRect();\n    const x = e.clientX - rect.left;\n    const y = e.clientY - rect.top;\n    let i = 0;\n    let box;\n    let segment;\n\n    if (this.props.props.Image.showBboxes && this.props.props.Image.showKeypoints && this.imageHasBeenLoaded) {\n      ctx.clearRect(0, 0, e.target.width, e.target.height);\n\n      while (i < this.data.bboxes.length) {\n        box = this.data.bboxes[i];\n        segment = this.data.segments[i];\n        ctx.beginPath();\n        ctx.rect(box[0], box[1], box[2], box[3]);\n        const [R, G, B] = this.hColors[i].slice(5, this.hColors[i].length).split(',');\n        ctx.fillStyle = ctx.isPointInPath(x, y) ? `rgba(${R},${G},${B},0.6)` : this.hColors[i];\n\n        if (ctx.isPointInPath(x, y)) {\n          try {\n            this.tooltipRef.current.innerText = this.props.props.Image.info.bboxes[i].category;\n          } catch (e) {\n            console.log('Maybe we can find category for chosen segment');\n          }\n        }\n\n        ctx.fill();\n        ctx.beginPath();\n        ctx.moveTo(segment[0], segment[1]);\n\n        for (let j = 2; j < segment.length - 1; j += 2) {\n          ctx.lineTo(segment[j], segment[j + 1]);\n        }\n\n        ctx.lineTo(segment[0], segment[1]);\n        ctx.lineWidth = 8;\n        ctx.stroke(); // ctx.fillStyle = this.hColors[i];\n\n        ctx.fill();\n        ctx.beginPath();\n        i++;\n      }\n    } else if (this.props.props.Image.showKeypoints && this.imageHasBeenLoaded) {\n      ctx.clearRect(0, 0, e.target.width, e.target.height);\n      const totalLengthOfSegs = this.data.segments.length === 1 ? 1 : this.data.segments.length;\n\n      while (i < totalLengthOfSegs) {\n        try {\n          segment = this.data.segments[i];\n          ctx.beginPath();\n          const [R, G, B] = this.hColors[i].slice(5, this.hColors[i].length).split(',');\n          ctx.fillStyle = ctx.isPointInPath(x, y) ? `rgba(${R},${G},${B},0.6)` : this.hColors[i];\n          ctx.moveTo(segment[0], segment[1]);\n\n          for (let j = 2; j < segment.length - 1; j += 2) {\n            ctx.lineTo(segment[j], segment[j + 1]);\n          }\n\n          ctx.lineTo(segment[0], segment[1]);\n          ctx.lineWidth = 8;\n          ctx.stroke();\n          ctx.fillStyle = ctx.isPointInPath(x, y) ? `rgba(${R},${G},${B},0.6)` : this.hColors[i];\n          ctx.fill();\n\n          if (ctx.isPointInPath(x, y)) {\n            try {\n              this.tooltipRef.current.innerText = this.props.props.Image.info.bboxes[i].category;\n            } catch (e) {\n              console.log('Maybe we can find category for chosen segment');\n            }\n          }\n\n          ctx.beginPath();\n          i++;\n        } catch (e) {\n          console.log(e);\n        }\n      }\n    } else if (this.props.props.Image.showBboxes && this.imageHasBeenLoaded) {\n      ctx.clearRect(0, 0, e.target.width, e.target.height);\n\n      while (i < this.data.bboxes.length) {\n        box = this.data.bboxes[i];\n        ctx.beginPath();\n        ctx.rect(box[0], box[1], box[2], box[3]);\n        const [R, G, B] = this.hColors[i].slice(5, this.hColors[i].length).split(',');\n        ctx.fillStyle = ctx.isPointInPath(x, y) ? `rgba(${R},${G},${B},0.6)` : this.hColors[i];\n\n        if (ctx.isPointInPath(x, y)) {\n          try {\n            this.tooltipRef.current.innerText = this.props.props.Image.info.bboxes[i].category;\n          } catch (e) {\n            console.log('Maybe we can find category for chosen segment');\n          }\n        }\n\n        ctx.fill();\n        i++;\n      }\n    } // if(this.props.props.Image.showKeypoints && this.imageHasBeenLoaded){\n    //\n    // \tconsole.log('1');\n    //\n    // \twhile (i < this.data.segments.length) {\n    // \t\tsegment =\n    // \t}\n    //\n    // }\n\n  } // fillWithKeypoints(){\n  // \tconst ctxForeground = this.canvasForeground.getContext('2d');\n  //\n  // \tconst keypoints:number[] = [];\n  // \tconst descriptions: string[] = [];\n  //\n  // \tthis.props.props.Image.info.segments.forEach((segment, index)=>{\n  //\n  // \t\ttry {\n  //\n  // \t\t\t// eslint-disable-next-line @typescript-eslint/ban-ts-comment\n  // \t\t\t// @ts-ignore\n  // \t\t\tkeypoints.push(segment.segments[0]);\n  // \t\t\tdescriptions.push(segment.category);\n  // \t\t\tctxForeground.beginPath();\n  // \t\t\tctxForeground.moveTo(segment.segments[0][0], segment.segments[0][1]);\n  // \t\t\tfor (let i = 2; i < segment.segments[0].length - 1; i += 2) {\n  //\n  // \t\t\t\tctxForeground.lineTo(segment.segments[0][i], segment.segments[0][i + 1]);\n  //\n  // \t\t\t}\n  // \t\t\tctxForeground.lineTo(segment.segments[0][0], segment.segments[0][1]);\n  // \t\t\tctxForeground.lineWidth = 8;\n  // \t\t\tctxForeground.stroke();\n  // \t\t\tctxForeground.fillStyle = this.hColors[index];\n  // \t\t\tctxForeground.fill();\n  // \t\t\tctxForeground.beginPath();\n  // \t\t}catch (e) {\n  // \t\t\tconsole.log(e);\n  // \t\t}\n  // \t});\n  // \t//console.log(keypoints);\n  // \treturn [keypoints, descriptions];\n  // }\n\n\n  updateImage() {\n    this.imageHasBeenLoaded = false;\n    const bboxes = [];\n    const descriptions = [];\n    const segments = [];\n    const imageObj1 = new Image(); //console.log(this.props.props.Image.url);\n\n    imageObj1.src = this.props.props.Image.url;\n\n    imageObj1.onload = () => {\n      const ctx = this.canvas.getContext('2d');\n      const ctxForeground = this.canvasForeground.getContext('2d');\n      ctx.drawImage(imageObj1, 0, 0);\n\n      if (this.props.props.Image.showBboxes) {\n        ctxForeground.clearRect(0, 0, this.props.props.Image.width, this.props.props.Image.height);\n        this.props.props.Image.info.bboxes.forEach((bbox, index) => {\n          const fillColor = this.hColors[index]; //console.log(colors[index]);\n\n          bboxes.push(bbox.box);\n          descriptions.push(bbox.category);\n          ctxForeground.fillStyle = fillColor;\n          ctxForeground.fillRect(bbox.box[0], bbox.box[1], bbox.box[2], bbox.box[3]);\n        });\n\n        if (this.data.segments.length === 0) {\n          this.data = {\n            bboxes: bboxes,\n            segments: [],\n            descriptions: descriptions\n          };\n        } else {\n          this.data = {\n            bboxes: this.data.bboxes,\n            segments: this.data.segments,\n            descriptions: this.data.descriptions\n          };\n        }\n      } else {\n        ctxForeground.clearRect(0, 0, this.props.props.Image.width, this.props.props.Image.height);\n      }\n\n      if (this.props.props.Image.showKeypoints) {\n        this.props.props.Image.info.segments.forEach((segment, index) => {\n          try {\n            segments.push(segment.segments[0]);\n\n            if (descriptions.length === 0) {\n              descriptions.push(segment.category);\n            }\n\n            ctxForeground.beginPath();\n            ctxForeground.moveTo(segment.segments[0][0], segment.segments[0][1]);\n\n            for (let i = 2; i < segment.segments[0].length - 1; i += 2) {\n              ctxForeground.lineTo(segment.segments[0][i], segment.segments[0][i + 1]);\n            }\n\n            ctxForeground.lineTo(segment.segments[0][0], segment.segments[0][1]);\n            ctxForeground.lineWidth = 8;\n            ctxForeground.stroke();\n            ctxForeground.fillStyle = this.hColors[index];\n            ctxForeground.fill();\n            ctxForeground.beginPath();\n          } catch (e) {\n            console.log(e);\n          }\n        }); //console.log(segs);\n\n        if (this.data.bboxes.length !== 0) {\n          this.data = {\n            bboxes: bboxes,\n            segments: segments,\n            descriptions: this.data.descriptions\n          };\n        } else {\n          this.data = {\n            bboxes: bboxes,\n            segments: segments,\n            descriptions: descriptions\n          };\n        }\n      }\n\n      this.imageHasBeenLoaded = true;\n\n      try {\n        this.tooltipRef.current.innerText = '';\n      } catch (e) {\n        console.log('');\n      }\n    };\n  }\n\n  componentDidUpdate(prevProps) {\n    //\n    if (this.props.props.Image.showBboxes === true) {\n      //console.log('On');\n      this.updateImage();\n    } else {\n      //console.log('Off');\n      this.updateImage();\n    }\n\n    if (this.props.props.Image.showKeypoints === true) {\n      //console.log('segments true');\n      this.updateImage();\n    } else {\n      //console.log('segments false');\n      this.updateImage();\n    }\n  }\n\n  render() {\n    return /*#__PURE__*/_jsxDEV(\"div\", {\n      children: /*#__PURE__*/_jsxDEV(OverlayTrigger, {\n        placement: 'bottom',\n        overlay: /*#__PURE__*/_jsxDEV(Tooltip, {\n          id: \"tooltip-disabled\",\n          children: /*#__PURE__*/_jsxDEV(\"i\", {\n            ref: this.tooltipRef,\n            children: \" \"\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 342,\n            columnNumber: 83\n          }, this)\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 342,\n          columnNumber: 52\n        }, this),\n        children: /*#__PURE__*/_jsxDEV(\"div\", {\n          style: {\n            display: 'flex'\n          },\n          children: [/*#__PURE__*/_jsxDEV(\"canvas\", {\n            style: {\n              zIndex: 1\n            },\n            ref: canvas => this.canvas = canvas,\n            width: this.props.props.Image.width,\n            height: this.props.props.Image.height,\n            children: \" \"\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 344,\n            columnNumber: 7\n          }, this), /*#__PURE__*/_jsxDEV(\"canvas\", {\n            style: {\n              top: 0,\n              zIndex: 2,\n              marginLeft: `-${this.props.props.Image.width}px`\n            },\n            onMouseMove: this.handleMouse.bind(this),\n            ref: canvas => this.canvasForeground = canvas,\n            width: this.props.props.Image.width,\n            height: this.props.props.Image.height\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 345,\n            columnNumber: 7\n          }, this)]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 343,\n          columnNumber: 6\n        }, this)\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 342,\n        columnNumber: 5\n      }, this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 340,\n      columnNumber: 4\n    }, this);\n  }\n\n}","map":{"version":3,"sources":["C:/Users/Bumpy/WebstormProjects/volfproject/src/components/drawCOCOimage.tsx"],"names":["React","randomColor","OverlayTrigger","Tooltip","DrawCOCOimage","Component","constructor","props","canvas","canvasForeground","imageHasBeenLoaded","tooltipRef","data","hColors","Array","from","length","createRef","bboxes","segments","descriptions","componentDidMount","updateImage","handleMouse","e","ctx","getContext","rect","getBoundingClientRect","x","clientX","left","y","clientY","top","i","box","segment","Image","showBboxes","showKeypoints","clearRect","target","width","height","beginPath","R","G","B","slice","split","fillStyle","isPointInPath","current","innerText","info","category","console","log","fill","moveTo","j","lineTo","lineWidth","stroke","totalLengthOfSegs","imageObj1","src","url","onload","ctxForeground","drawImage","forEach","bbox","index","fillColor","push","fillRect","componentDidUpdate","prevProps","render","display","zIndex","marginLeft","bind"],"mappings":"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","sourcesContent":["import React from 'react';\r\n//import * as React from 'react';\r\nimport {CommandsInterface, randomColor} from '../interfaces/SortInterfaces';\r\nimport {OverlayTrigger, Tooltip} from 'react-bootstrap';\r\nimport {ReactDOM} from 'react';\r\n\r\ninterface bbox{\r\n\tbox: number[],\r\n\tcategory:string\r\n}\r\ninterface segment{\r\n\tsegments: number[]\r\n}\r\n\r\ninterface segments{\r\n\tarea: number,\r\n\tsegments: number[][],\r\n\tcategory:string\r\n}\r\n\r\n\r\ninterface props{\r\n\tprops: {\r\n\t\tImage:{\r\n\t\tfilename: string,\r\n\t\turl: string,\r\n\t\theight: number,\r\n\t\twidth: number,\r\n\t\tinfo: {\r\n\t\t\tbboxes: bbox[],\r\n\t\t\tsegments: segments[]\r\n\t\t},\r\n\t\tshowBboxes: boolean,\r\n\t\tshowKeypoints: boolean\r\n\t}\r\n\t}\r\n}\r\ninterface stateInterface{\r\n\tbboxes:number[][], segments: number[][], descriptions:string[]\r\n}\r\n\r\n\r\n\r\nexport class DrawCOCOimage extends React.Component<props, any>{\r\n\tpublic canvas:any;\r\n\tpublic canvasForeground:any;\r\n\tprivate imageHasBeenLoaded: boolean;\r\n\tpublic tooltipRef:any;\r\n\tprivate data:stateInterface;\r\n\tprivate hColors: string[];\r\n\tconstructor(props: any) {\r\n\t\tsuper(props);\r\n\t\tthis.hColors = Array.from({length: 150}, () => `rgba(${randomColor()}, ${randomColor()}, ${randomColor()}, 0.4`);\r\n\t\tthis.tooltipRef = React.createRef();\r\n\t\tthis.imageHasBeenLoaded = false;\r\n\t\tthis.data = { bboxes:[], segments:[], descriptions:[]};\r\n\r\n\t}\r\n\r\n\tcomponentDidMount() {\r\n\t\tthis.updateImage();\r\n\t}\r\n\r\n\r\n\thandleMouse(e:any){\r\n\r\n\t\tconst ctx = this.canvasForeground.getContext('2d');\r\n\t\tconst rect = this.canvasForeground.getBoundingClientRect();\r\n\t\tconst x = e.clientX - rect.left;\r\n\t\tconst y = e.clientY - rect.top;\r\n\t\tlet i = 0;\r\n\t\tlet box:number[];\r\n\t\tlet segment: number[];\r\n\r\n\r\n\t\tif(this.props.props.Image.showBboxes && this.props.props.Image.showKeypoints && this.imageHasBeenLoaded) {\r\n\t\t\tctx.clearRect(0, 0, e.target.width, e.target.height);\r\n\t\t\twhile (i < this.data.bboxes.length) {\r\n\t\t\t\tbox = this.data.bboxes[i];\r\n\t\t\t\tsegment = this.data.segments[i];\r\n\t\t\t\tctx.beginPath();\r\n\t\t\t\tctx.rect(box[0], box[1], box[2], box[3]);\r\n\t\t\t\tconst [R, G, B] = this.hColors[i].slice(5, this.hColors[i].length).split(',');\r\n\t\t\t\tctx.fillStyle = ctx.isPointInPath(x, y) ? `rgba(${R},${G},${B},0.6)` : this.hColors[i];\r\n\r\n\t\t\t\tif (ctx.isPointInPath(x, y)) {\r\n\t\t\t\t\ttry {\r\n\t\t\t\t\t\tthis.tooltipRef.current.innerText = this.props.props.Image.info.bboxes[i].category;\r\n\t\t\t\t\t}catch (e){\r\n\t\t\t\t\t\tconsole.log('Maybe we can find category for chosen segment');\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tctx.fill();\r\n\t\t\t\tctx.beginPath();\r\n\t\t\t\tctx.moveTo(segment[0], segment[1]);\r\n\t\t\t\tfor (let j = 2; j < segment.length - 1; j += 2) {\r\n\r\n\t\t\t\t\tctx.lineTo(segment[j], segment[j + 1]);\r\n\r\n\t\t\t\t}\r\n\t\t\t\tctx.lineTo(segment[0], segment[1]);\r\n\t\t\t\tctx.lineWidth = 8;\r\n\t\t\t\tctx.stroke();\r\n\t\t\t\t// ctx.fillStyle = this.hColors[i];\r\n\t\t\t\tctx.fill();\r\n\t\t\t\tctx.beginPath();\r\n\t\t\t\ti++;\r\n\t\t\t}\r\n\t\t}else if(this.props.props.Image.showKeypoints && this.imageHasBeenLoaded){\r\n\t\t\tctx.clearRect(0, 0, e.target.width, e.target.height);\r\n\t\t\tconst totalLengthOfSegs = this.data.segments.length===1? 1 : this.data.segments.length;\r\n\r\n\t\t\twhile (i < totalLengthOfSegs) {\r\n\r\n\t\t\t\ttry{\r\n\r\n\t\t\t\t\tsegment = this.data.segments[i];\r\n\t\t\t\t\tctx.beginPath();\r\n\t\t\t\t\tconst [R, G, B] = this.hColors[i].slice(5, this.hColors[i].length).split(',');\r\n\t\t\t\t\tctx.fillStyle = ctx.isPointInPath(x, y) ? `rgba(${R},${G},${B},0.6)` : this.hColors[i];\r\n\t\t\t\t\tctx.moveTo(segment[0], segment[1]);\r\n\t\t\t\t\tfor (let j = 2; j < segment.length - 1; j += 2) {\r\n\r\n\t\t\t\t\t\tctx.lineTo(segment[j], segment[j + 1]);\r\n\r\n\t\t\t\t\t}\r\n\t\t\t\t\tctx.lineTo(segment[0], segment[1]);\r\n\t\t\t\t\tctx.lineWidth = 8;\r\n\t\t\t\t\tctx.stroke();\r\n\r\n\t\t\t\t\tctx.fillStyle = ctx.isPointInPath(x, y) ? `rgba(${R},${G},${B},0.6)` : this.hColors[i];\r\n\t\t\t\t\tctx.fill();\r\n\t\t\t\t\tif (ctx.isPointInPath(x, y)) {\r\n\t\t\t\t\t\ttry {\r\n\t\t\t\t\t\t\tthis.tooltipRef.current.innerText = this.props.props.Image.info.bboxes[i].category;\r\n\t\t\t\t\t\t} catch (e) {\r\n\t\t\t\t\t\t\tconsole.log('Maybe we can find category for chosen segment');\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tctx.beginPath();\r\n\t\t\t\t\ti++;\r\n\t\t\t\t}catch(e){console.log(e)}\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\r\n\t\telse if (this.props.props.Image.showBboxes && this.imageHasBeenLoaded){\r\n\r\n\t\t\tctx.clearRect(0, 0, e.target.width, e.target.height);\r\n\r\n\t\t\twhile (i < this.data.bboxes.length) {\r\n\t\t\t\tbox = this.data.bboxes[i];\r\n\t\t\t\tctx.beginPath();\r\n\t\t\t\tctx.rect(box[0], box[1], box[2], box[3]);\r\n\t\t\t\tconst [R, G, B] = this.hColors[i].slice(5, this.hColors[i].length).split(',');\r\n\t\t\t\tctx.fillStyle = ctx.isPointInPath(x, y) ? `rgba(${R},${G},${B},0.6)` : this.hColors[i];\r\n\r\n\t\t\t\tif (ctx.isPointInPath(x, y)) {\r\n\t\t\t\t\ttry {\r\n\t\t\t\t\t\tthis.tooltipRef.current.innerText = this.props.props.Image.info.bboxes[i].category;\r\n\t\t\t\t\t}catch (e){\r\n\t\t\t\t\t\tconsole.log('Maybe we can find category for chosen segment');\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tctx.fill();\r\n\t\t\t\ti++;\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\r\n\r\n\r\n\r\n\t\t// if(this.props.props.Image.showKeypoints && this.imageHasBeenLoaded){\r\n\t\t//\r\n\t\t// \tconsole.log('1');\r\n\t\t//\r\n\t\t// \twhile (i < this.data.segments.length) {\r\n\t\t// \t\tsegment =\r\n\t\t// \t}\r\n\t\t//\r\n\t\t// }\r\n\t}\r\n\r\n\r\n\t// fillWithKeypoints(){\r\n\t// \tconst ctxForeground = this.canvasForeground.getContext('2d');\r\n\t//\r\n\t// \tconst keypoints:number[] = [];\r\n\t// \tconst descriptions: string[] = [];\r\n\t//\r\n\t// \tthis.props.props.Image.info.segments.forEach((segment, index)=>{\r\n\t//\r\n\t// \t\ttry {\r\n\t//\r\n\t// \t\t\t// eslint-disable-next-line @typescript-eslint/ban-ts-comment\r\n\t// \t\t\t// @ts-ignore\r\n\t// \t\t\tkeypoints.push(segment.segments[0]);\r\n\t// \t\t\tdescriptions.push(segment.category);\r\n\t// \t\t\tctxForeground.beginPath();\r\n\t// \t\t\tctxForeground.moveTo(segment.segments[0][0], segment.segments[0][1]);\r\n\t// \t\t\tfor (let i = 2; i < segment.segments[0].length - 1; i += 2) {\r\n\t//\r\n\t// \t\t\t\tctxForeground.lineTo(segment.segments[0][i], segment.segments[0][i + 1]);\r\n\t//\r\n\t// \t\t\t}\r\n\t// \t\t\tctxForeground.lineTo(segment.segments[0][0], segment.segments[0][1]);\r\n\t// \t\t\tctxForeground.lineWidth = 8;\r\n\t// \t\t\tctxForeground.stroke();\r\n\t// \t\t\tctxForeground.fillStyle = this.hColors[index];\r\n\t// \t\t\tctxForeground.fill();\r\n\t// \t\t\tctxForeground.beginPath();\r\n\t// \t\t}catch (e) {\r\n\t// \t\t\tconsole.log(e);\r\n\t// \t\t}\r\n\t// \t});\r\n\t// \t//console.log(keypoints);\r\n\t// \treturn [keypoints, descriptions];\r\n\t// }\r\n\r\n\r\n\tupdateImage(){\r\n\t\tthis.imageHasBeenLoaded = false;\r\n\t\tconst bboxes:number[][]=[];\r\n\t\tconst descriptions:string[] = [];\r\n\t\tconst segments: number[][]=[];\r\n\r\n\t\tconst imageObj1 = new Image();\r\n\t\t//console.log(this.props.props.Image.url);\r\n\t\timageObj1.src = this.props.props.Image.url;\r\n\t\timageObj1.onload = ()=> {\r\n\t\t\tconst ctx = this.canvas.getContext('2d');\r\n\t\t\tconst ctxForeground = this.canvasForeground.getContext('2d');\r\n\t\t\tctx.drawImage(imageObj1,0,0);\r\n\r\n\t\t\tif(this.props.props.Image.showBboxes) {\r\n\t\t\t\tctxForeground.clearRect(0,0,this.props.props.Image.width,this.props.props.Image.height);\r\n\t\t\t\tthis.props.props.Image.info.bboxes.forEach((bbox: any, index) => {\r\n\t\t\t\t\tconst fillColor = this.hColors[index];\r\n\t\t\t\t\t//console.log(colors[index]);\r\n\t\t\t\t\tbboxes.push(bbox.box);\r\n\t\t\t\t\tdescriptions.push(bbox.category);\r\n\t\t\t\t\tctxForeground.fillStyle = fillColor;\r\n\t\t\t\t\tctxForeground.fillRect(bbox.box[0], bbox.box[1], bbox.box[2], bbox.box[3]);\r\n\r\n\t\t\t\t});\r\n\r\n\t\t\t\tif(this.data.segments.length===0) {\r\n\t\t\t\t\tthis.data = {\r\n\t\t\t\t\t\tbboxes: bboxes as number[][],\r\n\t\t\t\t\t\tsegments: [],\r\n\t\t\t\t\t\tdescriptions: descriptions,\r\n\t\t\t\t\t};\r\n\t\t\t\t}else {\r\n\t\t\t\t\tthis.data = {bboxes:this.data.bboxes, segments: this.data.segments, descriptions: this.data.descriptions};\r\n\t\t\t\t}\r\n\r\n\r\n\t\t\t}else{\r\n\t\t\t\tctxForeground.clearRect(0,0,this.props.props.Image.width,this.props.props.Image.height);\r\n\t\t\t}\r\n\r\n\t\t\tif(this.props.props.Image.showKeypoints){\r\n\r\n\t\t\t\tthis.props.props.Image.info.segments.forEach((segment, index)=>{\r\n\r\n\t\t\t\t\ttry {\r\n\r\n\t\t\t\t\t\tsegments.push(segment.segments[0]);\r\n\t\t\t\t\t\tif (descriptions.length===0) {\r\n\t\t\t\t\t\t\tdescriptions.push(segment.category);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tctxForeground.beginPath();\r\n\t\t\t\t\t\tctxForeground.moveTo(segment.segments[0][0], segment.segments[0][1]);\r\n\t\t\t\t\t\tfor (let i = 2; i < segment.segments[0].length - 1; i += 2) {\r\n\r\n\t\t\t\t\t\t\tctxForeground.lineTo(segment.segments[0][i], segment.segments[0][i + 1]);\r\n\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tctxForeground.lineTo(segment.segments[0][0], segment.segments[0][1]);\r\n\t\t\t\t\t\tctxForeground.lineWidth = 8;\r\n\t\t\t\t\t\tctxForeground.stroke();\r\n\t\t\t\t\t\tctxForeground.fillStyle = this.hColors[index];\r\n\t\t\t\t\t\tctxForeground.fill();\r\n\t\t\t\t\t\tctxForeground.beginPath();\r\n\t\t\t\t\t}catch (e) {\r\n\t\t\t\t\t\tconsole.log(e);\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\r\n\t\t\t\t//console.log(segs);\r\n\r\n\t\t\t\tif(this.data.bboxes.length!==0){\r\n\r\n\t\t\t\t\tthis.data = {bboxes: bboxes as number[][], segments: segments, descriptions: this.data.descriptions};\r\n\r\n\t\t\t\t}else{\r\n\t\t\t\t\tthis.data = {bboxes: bboxes as number[][], segments: segments, descriptions: descriptions};\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis.imageHasBeenLoaded = true;\r\n\t\t\ttry {\r\n\t\t\t\tthis.tooltipRef.current.innerText = '';\r\n\t\t\t}catch (e){console.log(''); }\r\n\t\t};\r\n\t}\r\n\r\n\r\n\tcomponentDidUpdate(prevProps:props) {\r\n\t\t//\r\n\r\n\t\tif(this.props.props.Image.showBboxes===true){\r\n\t\t\t//console.log('On');\r\n\t\t\tthis.updateImage();\r\n\t\t}else{\r\n\t\t\t//console.log('Off');\r\n\t\t\tthis.updateImage();\r\n\t\t}\r\n\r\n\t\tif(this.props.props.Image.showKeypoints===true){\r\n\t\t\t//console.log('segments true');\r\n\t\t\tthis.updateImage();\r\n\t\t}else{\r\n\t\t\t//console.log('segments false');\r\n\t\t\tthis.updateImage();\r\n\t\t}\r\n\r\n\t}\r\n\r\n\r\n\r\n\r\n\trender() {\r\n\t\treturn (\r\n\t\t\t<div>\r\n\r\n\t\t\t\t<OverlayTrigger placement={'bottom'} overlay={ <Tooltip id=\"tooltip-disabled\"><i ref={this.tooltipRef}> </i></Tooltip> } >\r\n\t\t\t\t\t<div style={{ display: 'flex'}}>\r\n\t\t\t\t\t\t<canvas style={{zIndex:1}}   ref={(canvas)=>this.canvas=canvas} width={this.props.props.Image.width} height={this.props.props.Image.height}> </canvas>\r\n\t\t\t\t\t\t<canvas style={{top: 0,zIndex:2, marginLeft:`-${this.props.props.Image.width}px`}} onMouseMove={this.handleMouse.bind(this)} ref={(canvas)=>this.canvasForeground=canvas} width={this.props.props.Image.width} height={this.props.props.Image.height}></canvas>\r\n\t\t\t\t\t</div>\r\n\t\t\t\t</OverlayTrigger>\r\n\t\t\t</div>\r\n\t\t);\r\n\r\n\t}\r\n}\r\n"]},"metadata":{},"sourceType":"module"}